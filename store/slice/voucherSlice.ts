import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { Voucher } from '@/types/Voucher';
import { getAllVouchers, createVoucher, updateVoucher, deleteVoucher } from '@/_lib/voucher';

// Define the initial state of the vouchers
interface VoucherState {
  vouchers: Voucher[];
  total: number;
  loading: boolean;
  error: string | null;
}

const initialState: VoucherState = {
  vouchers: [],
  total: 0,
  loading: false,
  error: null,
};

// Create async actions (thunks) for fetching, creating, updating, and deleting vouchers

// Fetch all vouchers
export const fetchVouchers = createAsyncThunk(
  'vouchers/fetchVouchers',
  async ({ page, limit }: { page: number; limit: number }) => {
    const response = await getAllVouchers(page, limit);
    console.log(response)
    return response
  }
);

// Create a new voucher
export const addVoucher = createAsyncThunk(
  'vouchers/addVoucher',
  async (voucher: Voucher) => {
    return await createVoucher(voucher);
  }
);

// Update an existing voucher
export const modifyVoucher = createAsyncThunk(
  'vouchers/modifyVoucher',
  async ({ id, voucher }: { id: string; voucher: Voucher }) => {
    return await updateVoucher(id, voucher);
  }
);

// Delete a voucher
export const removeVoucher = createAsyncThunk(
  'vouchers/removeVoucher',
  async (id: string) => {
    return await deleteVoucher(id);
  }
);

// Create the slice
const voucherSlice = createSlice({
  name: 'vouchers',
  initialState,
  reducers: {
    // Any local actions if needed
  },
  extraReducers: (builder) => {
    builder
      // Fetching vouchers
      .addCase(fetchVouchers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchVouchers.fulfilled, (state, action: PayloadAction<{ total: number; vouchers: Voucher[] }>) => {
        state.loading = false;
        state.vouchers = action.payload.vouchers;
        state.total = action.payload.total;
      })
      .addCase(fetchVouchers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to fetch vouchers';
      })

      // Creating a voucher
      .addCase(addVoucher.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(addVoucher.fulfilled, (state, action: PayloadAction<Voucher>) => {
        state.loading = false;
        state.vouchers.push(action.payload); // Add the newly created voucher to the list
      })
      .addCase(addVoucher.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to create voucher';
      })

      // Updating a voucher
      .addCase(modifyVoucher.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(modifyVoucher.fulfilled, (state, action: PayloadAction<Voucher>) => {
        state.loading = false;
        // Find the updated voucher and replace it in the list
        const index = state.vouchers.findIndex(voucher => voucher._id === action.payload._id);
        if (index !== -1) {
          state.vouchers[index] = action.payload;
        }
      })
      .addCase(modifyVoucher.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to update voucher';
      })

      // Deleting a voucher
      .addCase(removeVoucher.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(removeVoucher.fulfilled, (state, action) => {
        state.loading = false;
        // Remove the deleted voucher from the list
        state.vouchers = state.vouchers.filter(voucher => voucher._id !== action.payload);
      })
      .addCase(removeVoucher.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message || 'Failed to delete voucher';
      });
  }
});

// Export the actions generated by the slice
export const {} = voucherSlice.actions;

// Export the reducer to be used in the store
export default voucherSlice.reducer;
